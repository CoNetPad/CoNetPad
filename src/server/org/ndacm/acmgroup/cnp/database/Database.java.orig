<<<<<<< HEAD
=======
/**
 * Class:  Database<br>
 * Description:  This is a class for handling our database stuff.
 * See IDatabase for comments  
 * @author Justin
 * @version 3.0
 */
>>>>>>> master
package org.ndacm.acmgroup.cnp.database;


import java.io.UnsupportedEncodingException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Random;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.ndacm.acmgroup.cnp.Account;
import org.ndacm.acmgroup.cnp.exceptions.FailedAccountException;
<<<<<<< HEAD
import org.ndacm.acmgroup.cnp.server.CNPPrivateSession;
import org.ndacm.acmgroup.cnp.server.CNPServer;
import org.ndacm.acmgroup.cnp.server.CNPSession;
=======
import org.ndacm.acmgroup.cnp.exceptions.FailedSessionException;
import org.ndacm.acmgroup.cnp.server.CNPPrivateSession;
import org.ndacm.acmgroup.cnp.server.CNPSession;
import org.ndacm.acmgroup.cnp.server.CNPSession.SessionType;

>>>>>>> master

/**
 * Class:  Database<br>
 * Description:  This is a class for handling our database stuff.  
 * 
 */
public class Database implements IDatabase{

	private static final String DRIVER_CLASS = "org.sqlite.JDBC";
	private static final String ENCRYPTION_ALGORITHM = "PBKDF2WithHmacSHA1";
	private static final String DB_FILE = "jdbc:sqlite:src//sqllite//CoNetPad.db3";

	private Connection dbConnection;
	private Random random;

	/**
	 * Default Constructor
	 * @throws SQLException 
	 * @throws Exception
	 */
	public Database() throws ClassNotFoundException, SQLException
	{
		Class.forName(DRIVER_CLASS);
		dbConnection = DriverManager.getConnection(DB_FILE);
		random = new Random();

	}
	/**
	 * createAccount()
	 * This Creates a new user account and returns an object
	 * @param username - String The string username you wish to use to create new account
	 * @param email - String The password of the new account
	 * @param password - String The RAW password to be given.  Encrpytion is done for you.
	 * @return Returns an new Account Object or throws an FailedAccountException
	 * @throws FailedAccountException 
	 */
<<<<<<< HEAD
	public Account createAccount(String username, String email, String password) throws FailedAccountException {

		Account newAccount = null;

		// salt and hash password
		// http://stackoverflow.com/questions/2860943/suggestions-for-library-to-hash-passwords-in-java
		// http://stackoverflow.com/questions/5499924/convert-java-string-to-byte-array
		String hashString = null, saltString = null;
		byte[] salt = new byte[16];
		random.nextBytes(salt);

		try {
			KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 2048, 160);
			SecretKeyFactory f = SecretKeyFactory.getInstance(ENCRYPTION_ALGORITHM);
			hashString = new String(f.generateSecret(spec).getEncoded());
			saltString = new String(salt, "ISO-8859-1");

			// test if username/email already exists

			// insert user into DB
			PreparedStatement registerUser = null;
			String insertion = "INSERT INTO UserAccount (Username, AccountPassword, AccountSalt, Email) "
					+ "VALUES (? , ?, ?, ?)";

			registerUser = dbConnection.prepareStatement(insertion);
			registerUser.setString(1, username);
			registerUser.setString(2, hashString);
			registerUser.setString(3, saltString);
			registerUser.setString(4, email);

			registerUser.executeUpdate();

			// return the account that was just inserted
			newAccount = retrieveAccount(username, password);

			registerUser.close();

		} catch (NoSuchAlgorithmException ex) {
			System.err.println("Invalid Encrpytion Algorithm: " + ENCRYPTION_ALGORITHM);
			throw new FailedAccountException("Error creating account for " + username);
		} catch (InvalidKeySpecException e) {
			System.err.println("Invalid key spec.");
			throw new FailedAccountException("Error creating account for " + username);
		} catch (UnsupportedEncodingException e) {
			System.err.println("Unsupported encoding.");
			throw new FailedAccountException("Error creating account for " + username);
		} catch (SQLException e) {
			System.err.println("SQL error.");
			throw new FailedAccountException("Error creating account for " + username);
=======
	public Account createAccount(String username, String email, String password) throws SQLException, FailedAccountException 
	{
		// TODO implement
		// also store in DB
		try
		{
		    String encryptPass = sha1(password);
		 
			String query = "INSERT INTO UserAccount (Username, AccountPassword, Email) VALUES ('" + username + "', '"
						+ encryptPass + "', '" + email + "');";
			int result =stmt.executeUpdate(query);
			if(result > 0)
			{
				query = "select last_insert_rowid();";
				ResultSet rs = stmt.executeQuery(query);
				int id = rs.getInt(1);
				return new Account(username, email, id);
			
			}
			else
			{
				
				throw new FailedAccountException();
			}
>>>>>>> master
		}

		if (newAccount != null) {
			return newAccount;
		} else {
			throw new FailedAccountException("Error creating account for " + username);
		}

	}
	/**
	 * retrieveAccount()
	 * Gets an existing account from the database and returns it into an Account Object
	 * @param username The username you wish to try and get
	 * @param password The password you wish to verify with.  Make sure its RAW and not encrypted.
	 * @return Account The account object of the the user account
	 * @throws FailedAccountException
	 */
<<<<<<< HEAD
	public Account retrieveAccount(String username, String password) throws FailedAccountException {

		// we should probably salt password too
		//		String query = null;
		//		try
		//		{
		//		    String encryptPass = sha1(password);
		//			query = "SELECT Username, Email FROM UserAccount WHERE Username='" + username + "' AND  AccountPassword='"
		//						+ encryptPass + "';";
		//			ResultSet rs = stmt.executeQuery(query);
		//			while(rs.next())
		//			{
		//				String uname = rs.getString("Username");
		//				String email = rs.getString("Email");
		//				return new Account(uname, email, 1); // TODO fix
		//			}
		//			throw new FailedAccountException("No Account Found");
		//			
		//		}
		//		catch(NoSuchAlgorithmException e)
		//		{
		//			throw new FailedAccountException("Encrpytion failed");
		//		}
		//		catch(SQLException e)
		//		{
		//			throw new FailedAccountException("SQL Error");
		//		}


		PreparedStatement retrieveAccount = null;
		ResultSet rset = null;
		Account accountRetrieved = null;
		String saltRetrieved = null;
		String hashRetrieved = null;

		String query = "SELECT * "
				+ "FROM UserAccount "
				+ "WHERE username = ?";

		try {
			// retrieve user with given username
			retrieveAccount = dbConnection.prepareStatement(query);
			retrieveAccount.setString(1, username);

			//run the query, return a result set        
			rset = retrieveAccount.executeQuery();

			int idRetrieved = rset.getInt("UserID");
			String nameRetrieved = rset.getString("UserName");
			String emailRetrieved = rset.getString("Email");
			accountRetrieved = new Account(idRetrieved, nameRetrieved, emailRetrieved);

			hashRetrieved = rset.getString("AccountPassword");
			saltRetrieved = rset.getString("AccountSalt");

			//clean up database classes
			retrieveAccount.close();
			rset.close();

		} catch (SQLException ex) {
			throw new FailedAccountException("Error retrieving account for " + username);
=======
	public Account retrieveAccount(String username, String password) throws SQLException, FailedAccountException {
		// TODO implement
		String query = null;
		try
		{
		    String encryptPass = sha1(password);
			query = "SELECT UserID, Username, Email FROM UserAccount WHERE Username='" + username + "' AND  AccountPassword='"
						+ encryptPass + "';";
			ResultSet rs = stmt.executeQuery(query);
			while(rs.next())
			{
				String uname = rs.getString("Username");
				String email = rs.getString("Email");
				int id = rs.getInt("UserID");
				return new Account(uname, email, id);
			}
			throw new FailedAccountException("No Account Found");
			
>>>>>>> master
		}

		String hashSupplied = null;

		// generate hash for the password string supplied (using the salt from userRetrieved)
		try {
			byte[] salt = saltRetrieved.getBytes("ISO-8859-1");
			KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 2048, 160);
			SecretKeyFactory f = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
			hashSupplied = new String(f.generateSecret(spec).getEncoded());
		} catch (NoSuchAlgorithmException ex) {
			System.err.println("Invalid Encrpytion Algorithm: " + ENCRYPTION_ALGORITHM);
			throw new FailedAccountException("Error retrieving account for " + username);
		} catch (UnsupportedEncodingException ex) {
			System.err.println("Unsupported encoding.");
			throw new FailedAccountException("Error retrieving account for " + username);
		} catch (InvalidKeySpecException ex) {
			System.err.println("Invalid key spec.");
			throw new FailedAccountException("Error retrieving account for " + username);
		}

		// check if hashes match. if so, return account.
		if (hashSupplied.equals(hashRetrieved)) {
			return accountRetrieved;
		} else {
			throw new FailedAccountException("Incorrect password supplied for " + username);
		}

	}
<<<<<<< HEAD


	public CNPSession createSession(int sessionLeader, CNPServer server) throws SQLException {

		// create session and store in database			
		CNPSession newSession = null;

		// TODO test if session already exists

		// insert session into DB
		PreparedStatement createSession = null;
		String sessionName = CNPSession.generateString(5);
		String insertion = "INSERT INTO Session (SessionLeader, SessionName, IsPublic) "
				+ "VALUES (? , ?, ?)";

		createSession = dbConnection.prepareStatement(insertion);
		createSession.setInt(1, sessionLeader);
		createSession.setString(2, sessionName);
		createSession.setBoolean(3, true);

		createSession.executeUpdate();

		// return the session that was just inserted
		newSession = retrieveSession(sessionName, server);

		createSession.close();

		return newSession;

	}

	public CNPPrivateSession createSession(int sessionLeader, CNPServer server, String sessionPassword) 
			throws SQLException {

		// create session and store in database
		CNPPrivateSession newSession = null;

		// TODO test if session already exists

		// salt and hash password
		// http://stackoverflow.com/questions/2860943/suggestions-for-library-to-hash-passwords-in-java
		// http://stackoverflow.com/questions/5499924/convert-java-string-to-byte-array
		String hashString = null, saltString = null;
		byte[] salt = new byte[16];
		random.nextBytes(salt);

		try {
			KeySpec spec = new PBEKeySpec(sessionPassword.toCharArray(), salt, 2048, 160);
			SecretKeyFactory f = SecretKeyFactory.getInstance(ENCRYPTION_ALGORITHM);
			hashString = new String(f.generateSecret(spec).getEncoded());
			saltString = new String(salt, "ISO-8859-1");

			// insert session into DB
			PreparedStatement createSession = null;
			String sessionName = CNPSession.generateString(5);
			String insertion = "INSERT INTO Session (SessionLeader, SessionName, IsPublic, SessionPassword, SessionSalt) "
					+ "VALUES (? , ?, ?, ?, ?)";

			createSession = dbConnection.prepareStatement(insertion);
			createSession.setInt(1, sessionLeader);
			createSession.setString(2, sessionName);
			createSession.setBoolean(3, false);
			createSession.setString(4, hashString);
			createSession.setString(5, saltString);

			createSession.executeUpdate();

			// return the account that was just inserted
			newSession = retrieveSession(sessionName, server, sessionPassword);

			createSession.close();

		} catch (NoSuchAlgorithmException ex) {
			System.err.println("Invalid Encrpytion Algorithm: " + ENCRYPTION_ALGORITHM);
			throw new FailedAccountException("Error creating session.");
		} catch (InvalidKeySpecException e) {
			System.err.println("Invalid key spec.");
			throw new FailedAccountException("Error creating session.");
		} catch (UnsupportedEncodingException e) {
			System.err.println("Unsupported encoding.");
			throw new FailedAccountException("Error creating session.");
=======
	
	/**
	 * createSession()
	 * This will create a new CNP Session
	 * @param sessionLeader	The session leader of the new session
	 * @param name 			The user-friendly name of the session
	 * @param channel		The IRC channel
	 * @param gpath			The path to the GIT
	 */
	public CNPSession createSession(Account sessionLeader, String name, String channel, String gPath) throws SQLException, FailedSessionException{
		// TODO implement
		String query = null;
		try
		{
			query = "INSERT INTO Session (SessionLeader, SessionName, SessionType, IrcChannel, GitPath) " +
					"VALUES(" + sessionLeader.getUserID() + ", '" + name + "', '" + SessionType.PUBLIC +
					"', '" + channel + "', '" + gPath + "');";
			int result =stmt.executeUpdate(query);
			if(result > 0)
			{
				return new CNPSession(sessionLeader, name, SessionType.PUBLIC, channel, gPath);
			}
			else
			{
				
				throw new FailedSessionException();
			}
		}
		catch(SQLException e)
		{
			throw e;
		}
		
	}
	
	@Override
	public CNPSession createSession(Account sessionLeader, String name,String channel, String gPath, String sessionPassword)throws SQLException, FailedSessionException {
		String query = null;
		try
		{
			query = "INSERT INTO Session (SessionLeader, SessionName, SessionType, IrcChannel, GitPath) " +
					"VALUES(" + sessionLeader.getUserID() + ", '" + name + "', '" + SessionType.PRIVATE.intValue() +
					"', '" + channel + "', '" + gPath + "');";
			int result =stmt.executeUpdate(query);
			if(result > 0)
			{
				try
				{
					query = "select last_insert_rowid();";
					ResultSet rs = stmt.executeQuery(query);
					int id = rs.getInt(1);
					if(id > 0)
					{
						String ePass = Database.sha1(sessionPassword);
						query = "INSERT INTO SessionPassword (SessionID, SessionPassword) VALUES (" + id + ", '"+ ePass + "');";
						result =stmt.executeUpdate(query);
						if(result > 0)
						{
							return new CNPSession(sessionLeader, name, SessionType.PRIVATE, channel, gPath, ePass);
						}
						else
						{
							throw new FailedSessionException("Could not insert sesison password");
						}
					}
					else
					{
						throw new FailedSessionException("Error with creating private password");
					}
				}
				catch(SQLException se)
				{
					throw se;
				}
				catch(NoSuchAlgorithmException e)
				{
					throw new FailedSessionException("Password failed");
				}
			}
			else
			{
				
				throw new FailedSessionException();
			}
		}
		catch(SQLException e)
		{
			throw e;
		}
	}
	public CNPSession retrieveSession(String sessionName)throws SQLException, FailedSessionException, FailedAccountException {
		String query = null;
		try
		{
			query = "SELECT SessionLeader, SessionName, SessionType, IrcChannel, GitPath FROM Session WHERE SessionName ='" + sessionName + "';";
			ResultSet rs = stmt.executeQuery(query);
			while(rs.next())
			{
				int sessionLeader = rs.getInt("SessionLeader");
				String name = rs.getString("SessionName");
				SessionType type = SessionType.getType( rs.getInt("SessionType") );
				String channel = rs.getString("IrcChannel");
				String gitPath = rs.getString("GitPath");
				Account act = getAccountById(sessionLeader);
				return new  CNPSession(act, name, type, channel, gitPath);
			}
			throw new FailedSessionException("No Session found");
		}
		catch(FailedAccountException e)
		{
			throw e;
		}
		catch(SQLException e)
		{
			throw e;
		}
	}
	
	public CNPSession retrieveSession(String sessionName, String sessionPassword)throws SQLException, FailedSessionException, FailedAccountException {
		String query = null;
		try
		{		
			query = "SELECT SessionID, SessionLeader, SessionName, SessionType, IrcChannel, GitPath FROM Session WHERE SessionName ='" + sessionName + "';";
			ResultSet rs = stmt.executeQuery(query);
			String ePass = sha1(sessionPassword);
			while(rs.next())
			{
				int sessionID = rs.getInt("SessionID");
				int sessionLeader = rs.getInt("SessionLeader");
				String name = rs.getString("SessionName");
				SessionType type = SessionType.getType( rs.getInt("SessionType") );
				String channel = rs.getString("IrcChannel");
				String gitPath = rs.getString("GitPath");
				Account act = getAccountById(sessionLeader);
				query = "SELECT SessionPassword FROM SessionPassword WHERE SessionID=" + sessionID + " LIMIT 1;";
				rs = stmt.executeQuery(query);
				while(rs.next())
				{
					String pass = rs.getString("SessionPassword");
					if(ePass.equals(pass))
					{	return new CNPSession(act, name, type, channel, gitPath, pass);	}
					else
					{	throw new FailedSessionException("Passwords for private session did not match");	}
				}
				throw new FailedSessionException("No Session found");
			}
			throw new FailedSessionException("No Session found");
		}
		catch(FailedAccountException e)
		{
			throw e;
		}
		catch(NoSuchAlgorithmException e)
		{
			throw new FailedSessionException("Error with encrpyting password");
		}
		catch(SQLException e)
		{
			throw e;
		}
	}
	
	public boolean sessionIsPrivate(String sessionName) {
		// TODO implement
		try{
			CNPSession session = this.retrieveSession(sessionName);
			if(session.getType() == SessionType.PRIVATE)
			{
				return true;
			}
				
		}
		catch(Exception e)
		{
			return false;
		}
		return false;
	}
	
//	public boolean createSessionAccount(CNPSession session, Account account,
//			Account.FilePermissionLevel filePermission, Account.ChatPermissionLevel chatPermission) {
//		// TODO implement
//		return false;
//	}
	
	public Account getAccountById(int id) throws SQLException, FailedAccountException
	{
		String query = null;
		try
		{
			query = "SELECT UserID, UserName, Email FROM UserAccount WHERE UserID =" + id + ";";
			ResultSet rs = stmt.executeQuery(query);
			while(rs.next())
			{
				int userID = rs.getInt("UserID");
				String userName = rs.getString("UserName");
				String email = rs.getString("Email");
				return new Account(userName, email, userID);
				
			}
		}
		catch(SQLException e)
		{
			throw e;
		}
		throw new FailedAccountException("Unable to retrive Account by database id.");
		
	}
	
	/**
	 * sha1()
	 * This returns the string version of the SHA1 Encryption
	 * @param input This is the string you wish to get the SHA1 Hash
	 * @return The encrypted value
	 * @throws NoSuchAlgorithmException
	 */
   public static String sha1(String input) throws NoSuchAlgorithmException
   {
		MessageDigest md = MessageDigest.getInstance("SHA1");
		md.update(input.getBytes()); 
		byte[] b = md.digest();
		char hexDigit[] = {'0', '1', '2', '3', '4', '5', '6', '7',
		 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
		StringBuffer buf = new StringBuffer();
		for (int j=0; j<b.length; j++) 
		{
			buf.append(hexDigit[(b[j] >> 4) & 0x0f]);
			buf.append(hexDigit[b[j] & 0x0f]);
>>>>>>> master
		}

		return newSession;
	}

<<<<<<< HEAD
	public CNPSession retrieveSession(String sessionName, CNPServer server) throws SQLException {

		PreparedStatement retrieveSession = null;
		ResultSet rset = null;
		CNPSession sessionRetrieved = null;

		String query = "SELECT * "
				+ "FROM Sesson "
				+ "WHERE SessionName = ?";


		// retrieve user with given username
		retrieveSession = dbConnection.prepareStatement(query);
		retrieveSession.setString(1, sessionName);

		//run the query, return a result set        
		rset = retrieveSession.executeQuery();

		int idRetrieved = rset.getInt("SessionID");
		String nameRetrieved = rset.getString("SessionName");
		int sessionLeader = rset.getInt("SessionLeader");
		sessionRetrieved = new CNPSession(idRetrieved, nameRetrieved, server, sessionLeader);

		//clean up database classes
		retrieveSession.close();
		rset.close();

		return sessionRetrieved;
	}

	public CNPPrivateSession retrieveSession(String sessionName, CNPServer server, String sessionPassword) {
		// TODO implement - will have to do join - also, i think SQLite actually does support foreign keys
		return new CNPPrivateSession(1, sessionName, server, 1, sessionPassword, "salt");
	}

	public boolean sessionIsPrivate(String sessionName) {
		// TODO implement
		return false;
	}

	public boolean createSessionAccount(CNPSession session, Account account,
			Account.FilePermissionLevel filePermission, Account.ChatPermissionLevel chatPermission) {
		// TODO implement
		return false;
	}

	// if we use this, we should salt the input before hashing
	//	/**
	//	 * sha1()
	//	 * This returns the string version of the SHA1 Encryption
	//	 * @param input This is the string you wish to get the SHA1 Hash
	//	 * @return The encrypted value
	//	 * @throws NoSuchAlgorithmException
	//	 */
	//   private static String sha1(String input) throws NoSuchAlgorithmException
	//   {
	//		MessageDigest md = MessageDigest.getInstance("SHA1");
	//		md.update(input.getBytes()); 
	//		byte[] b = md.digest();
	//		char hexDigit[] = {'0', '1', '2', '3', '4', '5', '6', '7',
	//		 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
	//		StringBuffer buf = new StringBuffer();
	//		for (int j=0; j<b.length; j++) 
	//		{
	//			buf.append(hexDigit[(b[j] >> 4) & 0x0f]);
	//			buf.append(hexDigit[b[j] & 0x0f]);
	//		}
	//		  return buf.toString();
	//	}
=======
>>>>>>> master

}


