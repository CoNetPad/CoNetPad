Risk Management:

Our software project is composed of different elements, the two main ones being the server and client. These components need to interact asynchronously and offer the user an experience of seamless collaboration with their teammates. For achieving this goal, we have defined five major risks that could affect our development cycle.

Potential errors related to sockets and network:

The number of connections and sockets open at one time can cause unexpected problems, so we therefore have to make sure that our server will be able to catch and handle any exception. Also, both the server and client need to work even in adverse conditions such as low bandwidth, high latency, or temporary disconnections. For testing these aspects, we will need to test our server and client under different conditions in order to make sure that they will be able to handle any connection problems. These tests will also aid in our understanding of the scalability of our application. We will develop a testing tool for quick and automated testing so that testing can be both frequent and efficient. In the case that we find that our network architecture does not work appropriately, we will simplify it by removing the number of sockets used or reducing the data sent and received. We will then accommodate to our limitations. All of our members have worked with sockets and networking so we are confident that the probability of this risk is relatively low.

Problems with database concurrency and data integrity:

Having multiple sources edit a single file at once is a common source of concurrency problems and data loss. For overcoming this problem, our team is thinking of a queue-based program design that will prevent the problem of multiple writes to a file while maintaining the sensation of concurrent editing for the users. To make sure this system works, we will need to develop a prototype early on in our development cycle and test it via stress tests so that we can be confident about its reliability. This is an important requirement as this is going to be a main component of our server. Also, regular tests are going to be made to make sure that the reliability is maintained throughout the entire development process. In the case that the database has problems with concurrency which we cannot fix (due to our approach), then we will need to move to a more traditional approach like using a database lock. In the worst case scenario, we would need to remove the real-time editing feature.

Latency problems with network:

Our application is a collaboration tool that aims to offer real-time collaboration on more or more files. This requires low latency between the time an action is triggered by a user and the time this action is received by all users.  For achieving this goal, we will test the client and server under different circumstances, making sure that each message takes less than 1 second between the time it is sent and the time it is received. This testing will be done periodically and after any significant changes in the code to ensure that latency problems do not arise. If latency problems do arise, we may modify the frequency and/or size of the data exchanges on the network.

Time constraints due to personal circumstances:

There is always the possibility that personal circumstances occur which may conflict with this project. Also, all the team members are active members of the Association for Computing Machinery, which may cause some time conflicts, due to the fact that there are a large number of competitions, conferences and corporate events scheduled this semester. We can combat this risk using strict schedules and by continuously checking that we are on time with our progress. If any major deadlines happen to occur during an ACM event, we will make sure to schedule our project activities in such a way that we finish the work required for the deadline at a time before the ACM event occurs. If we fail to progress at the expected rate, we may be forced to cut from our feature set. However, we will always emphasize providing the best user experience, even in the case that we must limit our feature set.
